<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Cpp | 杨迦淇的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="C++期末复习0 考试题型1.选择6题 2.程序改错题（书的课后习题）写行号和原因 3.程序阅读理解题 4程序填空题 5.思辨题（简答题） 6.编程题 3.类和对象3.6初始化初始化列表 12345678910111213141516171819class Person &amp;#123;public:	&#x2F;&#x2F;&#x2F;&#x2F;传统方式初始化	&#x2F;&#x2F;Person(int a, int b, int c) &amp;#123;	&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp">
<meta property="og:url" content="http://example.com/2023/08/27/Cpp/index.html">
<meta property="og:site_name" content="杨迦淇的博客">
<meta property="og:description" content="C++期末复习0 考试题型1.选择6题 2.程序改错题（书的课后习题）写行号和原因 3.程序阅读理解题 4程序填空题 5.思辨题（简答题） 6.编程题 3.类和对象3.6初始化初始化列表 12345678910111213141516171819class Person &amp;#123;public:	&#x2F;&#x2F;&#x2F;&#x2F;传统方式初始化	&#x2F;&#x2F;Person(int a, int b, int c) &amp;#123;	&#x2F;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="c:\Users\universe">
<meta property="og:image" content="https://img-blog.csdnimg.cn/3756033faff443f4966433b7cb3e9b36.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/febf47fbae564359a6575d7e8ebe66f0.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a4177400a7264fdaa8438b163b63a19e.png#pic_center">
<meta property="article:published_time" content="2023-08-27T14:23:46.000Z">
<meta property="article:modified_time" content="2023-08-27T14:24:41.131Z">
<meta property="article:author" content="Jiaqi Yang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\universe">
  
    <link rel="alternate" href="/atom.xml" title="杨迦淇的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">杨迦淇的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">测试版</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Cpp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/27/Cpp/" class="article-date">
  <time class="dt-published" datetime="2023-08-27T14:23:46.000Z" itemprop="datePublished">2023-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Cpp
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="C-期末复习"><a href="#C-期末复习" class="headerlink" title="C++期末复习"></a>C++期末复习</h1><h2 id="0-考试题型"><a href="#0-考试题型" class="headerlink" title="0 考试题型"></a>0 考试题型</h2><p>1.选择6题</p>
<p>2.程序改错题（书的课后习题）写行号和原因</p>
<p>3.程序阅读理解题</p>
<p>4程序填空题</p>
<p>5.思辨题（简答题）</p>
<p>6.编程题</p>
<h2 id="3-类和对象"><a href="#3-类和对象" class="headerlink" title="3.类和对象"></a>3.类和对象</h2><h3 id="3-6初始化"><a href="#3-6初始化" class="headerlink" title="3.6初始化"></a>3.6初始化</h3><p>初始化列表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	<span class="comment">////传统方式初始化</span></span><br><span class="line">	<span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">	<span class="comment">//	m_A = a;</span></span><br><span class="line">	<span class="comment">//	m_B = b;</span></span><br><span class="line">	<span class="comment">//	m_C = c;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表方式初始化</span></span><br><span class="line">	Person(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :m_A(a), m_B(b), m_C(c) &#123;&#125;</span><br><span class="line">    <span class="comment">//两种都行Person(int a=1, int b=2, int c=3) :m_A&#123;a&#125;, m_B&#123;b&#125;, m_C&#123;c&#125; &#123;&#125;</span></span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>











<h2 id="4-继承"><a href="#4-继承" class="headerlink" title="4.继承"></a>4.继承</h2><h2 id="5-多态性"><a href="#5-多态性" class="headerlink" title="5 多态性"></a>5 多态性</h2><h3 id="5-2习题"><a href="#5-2习题" class="headerlink" title="5.2习题"></a>5.2习题</h3><p>完全看不懂</p>
<p>1</p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230126144304194.png" alt="image-20230126144304194"></p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230126144331318.png" alt="image-20230126144331318"></p>
<p>2</p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230126144632285.png" alt="image-20230126144632285"></p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230126144706349.png" alt="image-20230126144706349"></p>
<h2 id="6-运算符重载"><a href="#6-运算符重载" class="headerlink" title="6 运算符重载"></a>6 运算符重载</h2><h3 id="6-1运算符重载基础"><a href="#6-1运算符重载基础" class="headerlink" title="6.1运算符重载基础"></a>6.1运算符重载基础</h3><p>重载形式</p>
<p>1.非静态成员运算符重载</p>
<p>参数比实际少一个，少的参数用this指针隐性传递</p>
<p>2.友元运算符重载</p>
<p>与实际需要参数个数相同</p>
<p>3.普通函数 </p>
<h3 id="6-2-重载二元运算符"><a href="#6-2-重载二元运算符" class="headerlink" title="6.2 重载二元运算符"></a>6.2 重载二元运算符</h3><p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20221128205220572.png" alt="image-20221128205220572"></p>
<h3 id="6-3重载一元运算符（输入输出）"><a href="#6-3重载一元运算符（输入输出）" class="headerlink" title="6.3重载一元运算符（输入输出）"></a>6.3重载一元运算符（输入输出）</h3><p>只能利用全局函数重载，因为<code>cout</code>的成员函数定义在工程文件里，<code>cpp</code>不是开源的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不知道返回什么类型，先写void</span></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; p.real_ &lt;&lt; p.image_;</span><br><span class="line">&#125;<span class="comment">//无返回值在某些情况下也行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数调用，&lt;&lt;endl前需要cout的类型，即ostream</span></span><br><span class="line"><span class="comment">//由于ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; p.real_ &lt;&lt; p.image_;</span><br><span class="line">	<span class="keyword">return</span> os;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若Person类中的m_a,m_b改为private</span></span><br><span class="line"><span class="comment">//全局的运算符重载无法访问，则需要添加友元语句</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> Person&amp; p);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
<h3 id="6-4特殊运算符重载"><a href="#6-4特殊运算符重载" class="headerlink" title="6.4特殊运算符重载"></a>6.4特殊运算符重载</h3><h4 id="6-4-1-和–"><a href="#6-4-1-和–" class="headerlink" title="6.4.1++和–"></a>6.4.1++和–</h4><p>分前自增和后自增</p>
<p>如果为前缀运算符，采用常规重载方法；后缀，在参数表里加一个无用的形式参数，无实际意义只有类型名。</p>
<p>区别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;a++&lt;&lt;endl;<span class="comment">//输出a的大小，即1 </span></span><br><span class="line">	cout&lt;&lt;++a&lt;&lt;endl; <span class="comment">//3 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> i=<span class="number">0</span>)&#123; n=i;&#125;</span><br><span class="line">	<span class="comment">//类</span></span><br><span class="line">	X&amp; <span class="keyword">operator</span>++();</span><br><span class="line">	X <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//友元</span></span><br><span class="line">	<span class="keyword">friend</span> X&amp; <span class="keyword">operator</span>++(X &amp;c);</span><br><span class="line">	<span class="keyword">friend</span> X <span class="keyword">operator</span>++(X &amp;c,<span class="type">int</span>);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X&amp; X::<span class="keyword">operator</span>++()<span class="comment">//x后加&amp;：为了对同一个数进行递增</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先   进行++运算</span></span><br><span class="line">    <span class="comment">//后   返回自身</span></span><br><span class="line">	++n;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X X::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先   记录当时结果</span></span><br><span class="line">    <span class="comment">//再   进行++运算</span></span><br><span class="line">    <span class="comment">//最后return</span></span><br><span class="line">    <span class="function">X <span class="title">t</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//等于X t=*this</span></span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X&amp; <span class="keyword">operator</span>--(X &amp;c)</span><br><span class="line">&#123;</span><br><span class="line">	--c.n;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X <span class="keyword">operator</span>--(X &amp;c,<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">X <span class="title">t</span><span class="params">(c)</span></span>; </span><br><span class="line">	c,n--;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X a;</span><br><span class="line">    a.<span class="built_in">display</span>();</span><br><span class="line">    ++a;</span><br><span class="line">    a.<span class="built_in">display</span>();</span><br><span class="line">    a++;</span><br><span class="line">    a.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-4-2赋值运算符-和下标【】"><a href="#6-4-2赋值运算符-和下标【】" class="headerlink" title="6.4.2赋值运算符&#x3D;和下标【】"></a>6.4.2赋值运算符&#x3D;和下标【】</h4><p><strong>赋值运算符</strong></p>
<p>只能用成员函数定义</p>
<p>浅拷贝改为深拷贝，需要重载</p>
<p>什么时候需要深拷贝？如图：</p>
<p>（成员在堆中开辟了空间）</p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230125215925671.png" alt="image-20230125215925671"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);	<span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载赋值运算符 </span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;<span class="comment">//先清空本来的数据</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">//编译器提供的代码是浅拷贝  m_Age = p.m_Age;</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);<span class="comment">//提供深拷贝 解决浅拷贝的问题 *解引用</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回自身</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> *m_Age;<span class="comment">//年龄的指针</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>关于重载函数返回值，通过a&#x3D;b&#x3D;c，保持类型不变可以传递就行。</p>
<p><strong>下标运算符</strong>&#x3D;</p>
<p>二元运算符，第一个参数通过this指针传递，第二个参数代表数组下标</p>
<p>由于【】可以作为左值，所以返回引用</p>
<p>只能作为类的非静态成员函数</p>
<p>重载形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">...</span><br><span class="line">	X&amp; <span class="keyword">operator</span>[](<span class="type">int</span> n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230125222507930.png" alt="image-20230125222507930"></p>
<p>第二空，返回的是实部虚部，作为左值，需要加&amp;</p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230125222547186.png" alt="image-20230125222547186"></p>
<h4 id="6-4-3类型转换运算符"><a href="#6-4-3类型转换运算符" class="headerlink" title="6.4.3类型转换运算符"></a>6.4.3类型转换运算符</h4><p>类似于强转</p>
<p>重载形式：(将Y类型转换为X类型)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">Y</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>构造函数实现类型转化</strong></p>
<p>（定义的构造函数：给一个两个整数可以构造一个complex类型）</p>
<p>关键字：<code>explicit</code></p>
<p>在构造函数前加这个： 阻止隐式类型转换</p>
<h4 id="6-4-4函数调用运算符（）"><a href="#6-4-4函数调用运算符（）" class="headerlink" title="6.4.4函数调用运算符（）"></a>6.4.4函数调用运算符（）</h4><p>与函数的区别：这个函数名是个对象。</p>
<p>使用这个对象的时候，就像调用一个函数。  </p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230125223655823.png" alt="image-20230125223655823"></p>
<h3 id="6-5习题"><a href="#6-5习题" class="headerlink" title="6.5习题"></a>6.5习题</h3><p><strong>课堂举例</strong>：加法重载、插入重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> real_;</span><br><span class="line">	<span class="type">int</span> image_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span> (<span class="type">int</span> real=<span class="number">0</span>,<span class="type">int</span> image=<span class="number">0</span>):real_&#123;real&#125;,image_&#123;image&#125;&#123;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; cpx);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,<span class="type">const</span> Complex&amp; cpx);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; cpx)<span class="comment">//返回为右值，参数为只读</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;real_+cpx.real_,<span class="keyword">this</span>-&gt;image_+cpx.image_);<span class="comment">//匿名对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,<span class="type">const</span> Complex&amp; cpx)<span class="comment">//返回为左值，参数为cout左值、和只读右值                       </span></span><br><span class="line">&#123;</span><br><span class="line">    out&lt;&lt;cpx.real_&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;cpx.image_&lt;&lt;<span class="string">&quot;i&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;                           </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>                           </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>,<span class="title">c2</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>)</span>,c3</span>;</span><br><span class="line">    c3=c1+c2;</span><br><span class="line">    cout&lt;&lt;c3&lt;&lt;endl;</span><br><span class="line">&#125;                           </span><br></pre></td></tr></table></figure>

<p><strong>修改需求</strong>：</p>
<p><code>c3=c1+c2</code>改成<code>c3=c2+5</code>,</p>
<p>此时5为右值，5作为参数通过构造函数可以转换为<code>complex</code>类型，类的重载还可正常运行</p>
<p>改成<code>c3=5+c2</code>，</p>
<p>此时需将<code>5</code>转换为参数。因为全局所有操作数都作为参数，所以加法重载改成全局，</p>
<p>&#x3D;&#x3D;什么情况下返回参数要加引用？&#x3D;&#x3D;</p>
<p>返回的是值（只能做右值）还是对象本身空间（可以做左值）</p>
<p>右值：重载加法</p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230125235614622.png" alt="image-20230125235614622"></p>
<p>&#x3D;&#x3D;什么情况下函数参数要加<code>const</code>和<code>&amp;</code>?&#x3D;&#x3D;</p>
<p>避免拷贝构造函数的调用！</p>
<p>在只读需求下 <code>const X&amp;</code> 的方式最好（性能是最高的？）</p>
<p><strong>拓展：</strong></p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230126161137226.png" alt="image-20230126161137226"></p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230126161322669.png" alt="image-20230126161322669"></p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230125235722339.png" alt="image-20230125235722339"></p>
<p><strong>PTA程序题</strong></p>
<p>时间的比较（12月5号）</p>
<h2 id="7-STL"><a href="#7-STL" class="headerlink" title="7 STL"></a>7 STL</h2><h3 id="7-1模板"><a href="#7-1模板" class="headerlink" title="7.1模板"></a>7.1模板</h3><p><strong>函数模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a,T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a&gt;b)?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">max</span>(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//隐式</span></span><br><span class="line">	<span class="built_in">max</span>&lt;string&gt;(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;hollow&quot;</span>);<span class="comment">//显式</span></span><br><span class="line">    <span class="comment">//如果不加&lt;string&gt;，结果则是“hello”，一个一个字母比较的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>实例化</strong></p>
<p>函数模板，根据调用语句中实参的具体类型，推断数据类型，替换函数模板参数</p>
<p>生成模板的实例，称为<strong>模板函数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span><span class="params">(T1 a,T2 b)</span><span class="comment">//将返回值改为auto避免类型问题 eg.max（2，3.2）结果为3</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a&gt;b)?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>类型、非类型模板参数</strong></p>
<p>类型模板参数：如上面的例子</p>
<p>非类型：很像形参，只能传递常数。</p>
<h3 id="7-2类模板"><a href="#7-2类模板" class="headerlink" title="7.2类模板"></a>7.2类模板</h3><p><strong>与普通类的区别：</strong></p>
<p>类模板声明：</p>
<p>前面加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> MAXSIZE&gt;</span><br></pre></td></tr></table></figure>



<p>类模板成员函数定义：（类外）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 类名&lt;T ,MAXSIZE&gt;::函数名(T,e)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> T 类名&lt;T ,MAXSIZE&gt;::函数名(T,e)&#123;&#125;<span class="comment">//内联函数</span></span><br></pre></td></tr></table></figure>















<h3 id="7-3-STL"><a href="#7-3-STL" class="headerlink" title="7.3 STL"></a>7.3 STL</h3><p>类模板：容器、迭代器</p>
<p>函数模板：算法</p>
<h2 id="8-异常"><a href="#8-异常" class="headerlink" title="8 异常"></a>8 异常</h2><h3 id="8-1异常处理概述"><a href="#8-1异常处理概述" class="headerlink" title="8.1异常处理概述"></a>8.1异常处理概述</h3><p>“踹扔抓”</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	code to <span class="keyword">try</span>;</span><br><span class="line">	<span class="keyword">throw</span> an <span class="built_in">exception</span>(扔出异常) </span><br><span class="line">	</span><br><span class="line">	more code...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(type e)&#123;</span><br><span class="line">	类型是否匹配 <span class="number">1.</span>匹配抓住</span><br><span class="line">			   <span class="number">2.</span>不匹配，没人管，程序崩掉</span><br><span class="line"> code to process the exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>运行结果特点：</strong></p>
<p>1.try函数里throw后面语句不再执行</p>
<p>2.throw了异常已经被catch，后面的catch块将被略过</p>
<p>3.throw了的异常没有被任何一个catch块捕获，throw后面的程序都不再执行，显示“abnormal program termination”</p>
<p><strong>异常和函数</strong>：</p>
<p>1.在函数中处理异常</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">temperature</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">   		<span class="keyword">if</span>(t==<span class="number">100</span>) <span class="keyword">throw</span><span class="string">&quot;沸点“</span></span><br><span class="line"><span class="string">   		else cout&lt;&lt;&quot;</span>...<span class="string">&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">   catch(int x)&#123;cout&lt;&lt;...&lt;&lt;endl;&#125;</span></span><br><span class="line"><span class="string">   catch(char* s)&#123;cout&lt;&lt;s&lt;&lt;endl;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> 	temperature(100);</span></span><br><span class="line"><span class="string"> 	temperature(10);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>​          <code>catch</code>到的字符串用<code>char* s</code></p>
<p>2.在函数调用中处理异常（例如在主函数里）</p>
<p>​		（把catch的内容放在主函数，函数调用下面）</p>
<p>优点：</p>
<p>函数只抛出了异常，把异常检测和处理留给函数的调用者，</p>
<p>调用者可以跟据函数的实际调用情况进行异常的处理和调用，更合理。</p>
<p><strong>异常处理的几种特殊情况</strong></p>
<p>1.noexcept</p>
<p>​			C11之前异常规范为throw()或throw(…)</p>
<pre><code>       C11后用`noexcept`声明函数会不会产生异常
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_not_throw</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func_not_throw</span>(); <span class="comment">// 直接 terminate，不会被 catch</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">int</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>noexcept</code> 除了可以用作说明符（Specifier），也可以用作运算符（Operator）。<code>noexcept</code> 运算符是一个一元运算符，它的返回值是一个 bool 类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。例如，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(f))</span> </span>&#123; <span class="comment">// g() 是否是 noexcept 取决于 f()</span></span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.捕获所有异常</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">E</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">throw</span> n;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">throw</span> <span class="string">&quot;dx&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">3</span>) <span class="keyword">throw</span> <span class="number">1.1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (...) &#123; cout&lt;&lt;<span class="string">&quot;ok&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> 	<span class="built_in">E</span>(<span class="number">1</span>);</span><br><span class="line"> 	<span class="built_in">E</span>(<span class="number">2</span>);</span><br><span class="line"> 	<span class="built_in">E</span>(<span class="number">3</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>ok ok ok</p>
<p>3.再次抛出异常</p>
<p>一个catch里再次抛出的异常，会被传递给外部的catch块处理</p>
<p>若想修改异常对象的值，则需要将catch的类型声明为引用类型。</p>
<p>例如<code>catch（char* c）</code></p>
<p>4.异常的嵌套调用</p>
<p>一个try块中可以包含另一个try块。可以形成异常处理调用链。</p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230106211158307.png" alt="image-20230106211158307"></p>
<p>注意点：</p>
<p>fc()中一个try块对应一个catch块，</p>
<p>如果第一个try块中抛出的异常不能被第一个catch处理，</p>
<p>此时异常将会返回调用fc()的上一级try块对应的catch块中处理。</p>
<p>fc()第二个try和catch根本不会调用。</p>
<h3 id="8-2异常处理优点"><a href="#8-2异常处理优点" class="headerlink" title="8.2异常处理优点"></a>8.2异常处理优点</h3><p>简单错误简单办，用if判断就行</p>
<p>复杂错误异常办！</p>
<p><strong>优点</strong>：可将异常信息从&#x3D;&#x3D;被调函数带回给主调函数&#x3D;&#x3D;</p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20221218161139801.png" alt="image-20221218161139801"></p>
<h3 id="8-3异常处理和异常类"><a href="#8-3异常处理和异常类" class="headerlink" title="8.3异常处理和异常类"></a>8.3异常处理和异常类</h3><p>1.构造函数和异常</p>
<p>例如：类B有一个类A的对象成员数组<code>obj</code>，B的构造函数申请内存过量产生异常？</p>
<p>则异常将调用对象成员数组<code>obj</code>的析构函数，回收空间。</p>
<p>(类似异常的嵌套调用，类B通过判断扔出一个异常，类A析构函数相当于类B上一级的catch)</p>
<p>2.异常类</p>
<p>用来传递异常信息的类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Full</span>&#123;&#125;;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="built_in">catch</span>(stack::Full)&#123;...&#125;</span><br><span class="line">	<span class="built_in">catch</span>(stack::Empty)&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3.异常对象</p>
<p>由异常类建立的对象叫异常对象。</p>
<p>(异常对象可以传递异常信息，比如<code>s.push(40)</code>异常，可以将40这个信息输出，</p>
<p>如果异常类中没有数据对象，那么当<code>s.push(40)</code>异常，只能作为一种判断)</p>
<p>4.捕获异常对象的引用</p>
<p>和函数参数的传递一样，catch块捕获异常和参数传递方式也是两种：按值传递、按引用传递。</p>
<p>把<code>Full e</code>改为<code>Full &amp;s</code> (加个引用符就行)</p>
<h3 id="8-4-标准库异常类"><a href="#8-4-标准库异常类" class="headerlink" title="8.4 标准库异常类"></a>8.4 标准库异常类</h3><p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230108142440522.png" alt="image-20230108142440522"></p>
<p>基本异常：</p>
<p>文件系统异常（文件没有找到、访问的磁盘不存在）、</p>
<p>操作系统异常、</p>
<p>安全异常（口令错误、未授权用户）</p>
<p>头文件 #include<exceotion></p>
<p>class exception;</p>
<p>exception();&#x2F;&#x2F;构造函数</p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230108142858847.png"></p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230108143758209.png" alt="image-20230108143758209"></p>
<h3 id="8-5重抛异常"><a href="#8-5重抛异常" class="headerlink" title="8.5重抛异常"></a>8.5重抛异常</h3><p>异常处理程序可以重新抛出异常</p>
<p>什么情况下抛出另一个异常？</p>
<p>举例：</p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20221218214035874.png" alt="image-20221218214035874"></p>
<h3 id="8-6习题"><a href="#8-6习题" class="headerlink" title="8.6习题"></a>8.6习题</h3><p>1.异常嵌套</p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230106210612856.png" alt="image-20230106210612856"></p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230106210632990.png" alt="image-20230106210632990"></p>
<p><img src="C:\Users\universe'yang\AppData\Roaming\Typora\typora-user-images\image-20230106211158307.png" alt="image-20230106211158307"></p>
<p>2.判断异常类型</p>
<p>3.书上的读程序</p>
<p>8.4.2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">err</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(t&gt;<span class="number">100</span>) <span class="keyword">throw</span> <span class="string">&quot;biger than 100&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t&lt;<span class="number">-100</span>) <span class="keyword">throw</span> t;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;t in right range...&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(<span class="type">int</span> x)	&#123; 	cout&lt;&lt;<span class="string">&quot;error---&quot;</span>&lt;&lt;x&lt;&lt;endl;&#125;</span><br><span class="line">	<span class="built_in">catch</span>(<span class="type">const</span> <span class="type">char</span> *s)	&#123;	cout&lt;&lt;<span class="string">&quot;error---&quot;</span>&lt;&lt;s&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="comment">//为什么不加const会报错，系统匹配不到对应的catch？</span></span><br><span class="line">    <span class="comment">//terminate called after throwing an instance of &#x27;char const*&#x27;</span></span><br><span class="line">	<span class="built_in">catch</span>(<span class="type">float</span> f)  &#123;	cout&lt;&lt;<span class="string">&quot;error---&quot;</span>&lt;&lt;f&lt;&lt;endl;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">err</span>(<span class="number">200</span>);    								</span><br><span class="line">	<span class="built_in">err</span>(<span class="number">99</span>);  								 	</span><br><span class="line">	<span class="built_in">err</span>(<span class="number">-1210</span>);  								</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>8.4.3</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">excep</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> *ch;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">excep</span>(<span class="type">char</span> *m=<span class="string">&quot;exception class...&quot;</span>)&#123;ch=m;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cerr&lt;&lt;ch&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">err1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;enter err1\n&quot;</span>;</span><br><span class="line">	<span class="keyword">throw</span> <span class="built_in">excep</span>(<span class="string">&quot;exception&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">err2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;cout&lt;&lt;<span class="string">&quot;enter err2\n&quot;</span>;	<span class="built_in">err1</span>();	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(<span class="type">int</span>)&#123;cerr&lt;&lt;<span class="string">&quot;err2:catch\n&quot;</span>;	<span class="keyword">throw</span>;	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">err3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;	cout&lt;&lt;<span class="string">&quot;enter err3\n&quot;</span>;	<span class="built_in">err2</span>();	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(...)&#123;cerr&lt;&lt;<span class="string">&quot;err3:chtch\n&quot;</span>;	<span class="keyword">throw</span>;	&#125;<span class="comment">//注意 catch里面由throw！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;		<span class="built_in">err3</span>();	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(...)	&#123;	cerr&lt;&lt;<span class="string">&quot;main:catch\n&quot;</span>;	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.写程序</p>
<p>设计一个只能容纳10个元素的队列</p>
<h2 id="9习题"><a href="#9习题" class="headerlink" title="9习题"></a>9习题</h2><h3 id="9-1选择"><a href="#9-1选择" class="headerlink" title="9.1选择"></a>9.1选择</h3><p>当我们调用函数的时候，有时候我们并不需要返回值，由此可见此时编译器就不知道到底要调用哪个函数了，所以函数重载不能以返回值类型区分。</p>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">内联函数</a>是指用<strong>inline关键字</strong>修饰的函数</p>
<p>在类内定义的函数被默认成内联函数</p>
<p>内联函数从源代码层看，<strong>有函数的结构</strong>，而在编译后，却<strong>不具备函数的性质</strong></p>
<p>内联扩展是用来<strong>消除函数调用时的时间开销</strong></p>
<p>通常用于频繁执行的函数，对于小内存空间的函数非常受益</p>
<ul>
<li><p><strong>递归函数</strong>不能定义为内联函数</p>
</li>
<li><p>内联函数<strong>一般适合于</strong>不存在while和switch等复杂的结构且只有1~5条语句的小函数上，<strong>否则</strong>编译系统将该函数视为普通函数</p>
</li>
<li><p>内联函数<strong>只能</strong>先定义后使用，<strong>否则</strong>编译系统也会把它认为是普通函数</p>
</li>
<li><p>对内联函数<strong>不能进行异常的接口声明</strong></p>
</li>
</ul>
<blockquote>
<p>如果一个函数<strong>只能被本文件中其他函数所调用</strong>，它称为内部函数</p>
<p>在定义内部函数时，在函数名和函数类型的<strong>前面加 static</strong></p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> 类型名 函数名 （形参表）</span><br></pre></td></tr></table></figure>



<blockquote>
<p>如果在定义函数时，在函数的首部的<strong>最左端</strong>加关键字 <strong>extern</strong>，则此函数是外部函数，可供其它文件调用</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">max</span> (<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：如果在定义函数时<strong>省略 extern</strong>，则<strong>默认为外部函数</strong></p>
</blockquote>
<p>三种访问权限</p>
<p>public:可以被任意实体访问</p>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=protected&spm=1001.2101.3001.7020">protected</a>:只允许子类及本类的成员函数访问</p>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020">private</a>:只允许本类的成员函数访问</p>
<p>C++中派生类对基<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%B1%BB%E6%88%90%E5%91%98&spm=1001.2101.3001.7020">类成员</a>的访问形式主要有以下两种：<br>1、内部访问：由派生类中新增成员对基<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%B1%BB%E7%BB%A7%E6%89%BF&spm=1001.2101.3001.7020">类继承</a>来的成员的访问。<br>2、对象访问：在派生类外部，通过派生类的对象对从基类继承来的成员的访问。今天给大家介绍在3中继承方式下，派生类对基类成员的访问规则。</p>
<p>1、私有继承的访问规则<br>当类的继承方式为私有继承时，基类的public成员和protected成员被继承后成为派生类的private成员，派生类的其它成员可以直接访问它们，但是在类的外部通过派生类的对象无法访问。基类的private成员在私有派生类中是不可直接访问的，所以无论是派生类的成员还是通过派生类的对象，都无法直接访问从基类继承来的private成员，但是可以通过基类提供的public成员函数间接访问。</p>
<p><img src="https://img-blog.csdnimg.cn/3756033faff443f4966433b7cb3e9b36.png#pic_center" alt="img"></p>
<p>公有继承的访问规则<br>当类的继承方式为公有继承时，基类的public成员和protected成员被继承到派生类中仍作为派生类的public成员和protected成员，派生类的其它成员可以直接访问它们。但是，类的外部使用者只能通过派生类的对象访问继承来的public成员。基类的private成员在私有派生类中是不可直接访问的，所以无论是派生类成员还是派生类的对象，都无法直接访问从基类继承来的private成员，但是可以通过基类提供的public成员函数直接访问它们。公有继承的访问规则总结如下：<br><img src="https://img-blog.csdnimg.cn/febf47fbae564359a6575d7e8ebe66f0.png#pic_center" alt="img"></p>
<p>保护继承的访问规则<br>当类的继承方式为保护继承时，基类的public成员和protected成员被继承到派生类中都作为派生类的protected成员，派生类的其它成员可以直接访问它们，但是类的外部使用者不能通过派生类的对象访问它们。基类的private成员在私有派生类中是不可直接访问的，所以无论是派生类成员还是通过派生类的对象，都无法直接访问基类中的private成员。保护继承的访问规则总结如下：<br><img src="https://img-blog.csdnimg.cn/a4177400a7264fdaa8438b163b63a19e.png#pic_center" alt="img"></p>
<p>那些被virtual关键字修饰的成员函数，就是虚函数。虚函数的作用，用专业术语来解释就是实现多态性（Polymorphism），多态性是将接口与实现进行分离</p>
<p>指向基类的指针在操作它的多态类对象时，会根据不同的类对象，<br>调用其相应的函数，这个函数就是虚函数。</p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p>
<p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为抽象类</p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<ul>
<li>类体中的数据成员的声明前加上static关键字，该数据成员就成为了该类的静态数据成员。</li>
<li>静态数据成员实际上是类域中的全局变量。所以，<strong>静态数据成员的定义(初始化)不应该被放在头文件中（而是在相应的cpp文件中）。</strong></li>
</ul>
<p>静态数据成员：</p>
<ul>
<li><strong>和其他数据成员一样，静态数据成员也遵守public&#x2F;protected&#x2F;private访问规则。</strong></li>
<li>C++静态数据成员被类的所有对象所共享，包括该类派生类的对象。即派生类对象与基类对象共享基类的静态数据成员。</li>
</ul>
<p> 性质：</p>
<ul>
<li><p>C++静态数据成员可以成为成员函数的可选参数，而普通数据成员则不可以</p>
</li>
<li><p>在C++中，类的静态成员必须在类内声明，在类外初始化。因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。在类外定义和初始化是保证static成员变量只被定义一次的好方法。</p>
</li>
<li><p>static const int count &#x3D; 0;  静态整型常量成员就可以在类里面初始化，是因为它既然是const的，那程序就不会再去试图初始化了。</p>
<p>优点：</p>
</li>
</ul>
<p>不像全局变量，静态数据成员&#x2F;成员函数保存了类的封装性。静态数据成员&#x2F;成员函数相关于类，与对象的存毁无关。</p>
<ul>
<li>静态成员变量<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>&#x3D;&#x3D;类内声明，类外初始化&#x3D;&#x3D;</li>
</ul>
</li>
<li>静态成员函数<ul>
<li>所有对象共享同一个函数</li>
<li>&#x3D;&#x3D;静态成员函数只能访问静态成员变量&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<h3 id="9-2改错"><a href="#9-2改错" class="headerlink" title="9.2改错"></a>9.2改错</h3><p>1.private，public是否能访问</p>
<p>2.构造函数，初始化列表</p>
<p>3.const static运用</p>
<p>4.产生二义性</p>
<p>5没有写明命名空间（：：前面的限定）</p>
<p>初始化列表默认值</p>
<p>常数、引用必须初始化</p>
<p><strong>常量指针：<code>const int *p</code></strong></p>
<p>​		指向的是个常量，常量不能通过指针间接引用来改变</p>
<p><strong>指针常量：<code>int * const p</code></strong></p>
<p>​		指针本身固定指向。数组名是数组的首地址别名，即数组名就是个指针常量</p>
<p>(从左往右读,<code>const</code>前面是*p即p所指的变量值，则变量值不能变；<code>const</code>前面是p即指针，则指针所指方向不能变)</p>
<p>构造函数</p>
<p>初始化列表：</p>
<p>初始化 const 成员变量的唯一方法就是使用初始化列表</p>
<p>常见错因：</p>
<p><em>构造函数没有返回值</em></p>
<p>函数末尾const”只读 (read-only)”函数，说明这个函数不会修改任何数据成员 (object)。</p>
<ul>
<li>前面使用const 表示返回值为const</li>
<li>后面加 const表示函数不可以修改class的成员</li>
</ul>
<blockquote>
<p>当出现二义性的命名冲突的时候可以指明调用成员函数所属类来解决</p>
</blockquote>
<p>当派生类中含有对象成员时，构造函数调用顺序：基类构造函数→对象成员的构造函数→子类构造函数，析构函数则相反</p>
<p>注意：基类函数构造函数是否成功构造</p>
<p><strong>函数模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a,T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a&gt;b)?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">max</span>(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//隐式</span></span><br><span class="line">	<span class="built_in">max</span>&lt;string&gt;(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;hollow&quot;</span>);<span class="comment">//显式</span></span><br><span class="line">    <span class="comment">//如果不加&lt;string&gt;，结果则是“hello”，一个一个字母比较的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3程序"><a href="#9-3程序" class="headerlink" title="9.3程序"></a>9.3程序</h3><p>一个派生类构造函数的执行顺序：<br>第一步执行：虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。仅一次<br>第二步执行：基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。<br>第三步执行：类类型的成员对象的构造函数（按照初始化顺序）。</p>
<p><strong>成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。</strong>因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。</p>
<p>如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。</p>
<p>类中const成员常量必须在构造函数初始化列表中初始化。<br>类中static成员变量，必须在类外初始化。</p>
<p>第四部执行：派生类自己的构造函数。</p>
<p><strong>基类构造函数的调用顺序和和它们在派生类构造函数中出现的顺序无关，而是和声明派生类时基类出现的顺序相同</strong>。</p>
<p>class D: public A, private B, protected C{    <em>&#x2F;&#x2F;类D新增加的成员</em> }</p>
<p>1 基类的静态变量或全局变量</p>
<p>2 派生类的静态变量或全局变量</p>
<p>3 基类的成员变量</p>
<p>4 派生类的成员变量</p>
<p>++i：先增再用<br>i++：先用再增</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">X&amp; X::<span class="keyword">operator</span>++()<span class="comment">//x后加&amp;：为了对同一个数进行递增</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先   进行++运算</span></span><br><span class="line">    <span class="comment">//后   返回自身</span></span><br><span class="line">	++n;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X X::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先   记录当时结果</span></span><br><span class="line">    <span class="comment">//再   进行++运算</span></span><br><span class="line">    <span class="comment">//最后return</span></span><br><span class="line">    <span class="function">X <span class="title">t</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//等于X t=*this</span></span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/27/Cpp/" data-id="clltjlozl00008w1sdop3bu2k" data-title="Cpp" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/08/27/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2023/08/27/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/27/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/27/Cpp/">Cpp</a>
          </li>
        
          <li>
            <a href="/2023/08/27/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Jiaqi Yang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>